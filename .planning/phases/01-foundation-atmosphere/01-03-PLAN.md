---
phase: 01-foundation-atmosphere
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - client/src/state/canvasStore.ts
  - client/src/components/canvas/nodes/SnowballNode.tsx
  - client/src/components/canvas/edges/FootprintEdge.tsx
  - client/src/components/canvas/InfiniteCanvas.tsx
  - client/src/App.tsx
  - client/src/components/background/ParallaxBackground.tsx
autonomous: true

must_haves:
  truths:
    - "User can pan and zoom smoothly across an infinite canvas"
    - "Nodes appear as custom snowball-style elements with readable text"
    - "Edges appear as dashed footprint-style lines connecting nodes"
    - "Canvas, background, and all layers compose into a cohesive winter scene"
  artifacts:
    - path: "client/src/state/canvasStore.ts"
      provides: "Zustand store for React Flow controlled mode"
      exports: ["useCanvasStore"]
    - path: "client/src/components/canvas/nodes/SnowballNode.tsx"
      provides: "Custom memoized snowball node component"
      contains: "React.memo"
    - path: "client/src/components/canvas/edges/FootprintEdge.tsx"
      provides: "Custom dashed edge component"
      contains: "strokeDasharray"
    - path: "client/src/components/canvas/InfiniteCanvas.tsx"
      provides: "React Flow canvas with custom types"
      contains: "ReactFlow"
    - path: "client/src/App.tsx"
      provides: "Full app composition with all layers"
      contains: "ParallaxBackground"
  key_links:
    - from: "client/src/components/canvas/InfiniteCanvas.tsx"
      to: "client/src/state/canvasStore.ts"
      via: "Zustand store subscription"
      pattern: "useCanvasStore"
    - from: "client/src/components/canvas/InfiniteCanvas.tsx"
      to: "client/src/components/canvas/nodes/SnowballNode.tsx"
      via: "nodeTypes registration"
      pattern: "nodeTypes.*snowball"
    - from: "client/src/components/canvas/InfiniteCanvas.tsx"
      to: "client/src/components/canvas/edges/FootprintEdge.tsx"
      via: "edgeTypes registration"
      pattern: "edgeTypes.*footprint"
    - from: "client/src/App.tsx"
      to: "ParallaxBackground, InfiniteCanvas"
      via: "Component composition with z-index layering"
      pattern: "ParallaxBackground|InfiniteCanvas"
---

<objective>
Build the interactive React Flow infinite canvas with custom snowball nodes and footprint edges, then compose all visual layers into the final app.

Purpose: The canvas is the core interaction surface where users will explore knowledge. Custom snowball nodes and footprint edges establish the winter metaphor at the interaction level. Composing background + canvas + layout completes the Phase 1 visual experience that judges will see first.

Output: A fully interactive infinite canvas with custom-styled nodes and edges, layered on top of the parallax background, creating a cohesive atmospheric winter exploration experience.
</objective>

<execution_context>
@/Users/sahilpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sahilpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-atmosphere/01-RESEARCH.md
@.planning/phases/01-foundation-atmosphere/01-01-SUMMARY.md
@.planning/phases/01-foundation-atmosphere/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zustand canvas store and custom node/edge components</name>
  <files>
    client/src/state/canvasStore.ts
    client/src/components/canvas/nodes/SnowballNode.tsx
    client/src/components/canvas/edges/FootprintEdge.tsx
  </files>
  <action>
    **Zustand Canvas Store** (`client/src/state/canvasStore.ts`):
    Create a Zustand store for React Flow controlled mode following the official pattern from research:

    ```typescript
    import { create } from 'zustand'
    import {
      applyNodeChanges,
      applyEdgeChanges,
      type Node,
      type Edge,
      type OnNodesChange,
      type OnEdgesChange,
    } from '@xyflow/react'

    // Seed data for demo: a small topic tree
    const initialNodes: Node[] = [
      {
        id: '1',
        type: 'snowball',
        position: { x: 0, y: 0 },
        data: { label: 'The Universe' },
      },
      {
        id: '2',
        type: 'snowball',
        position: { x: -200, y: 150 },
        data: { label: 'Galaxies' },
      },
      {
        id: '3',
        type: 'snowball',
        position: { x: 200, y: 150 },
        data: { label: 'Dark Matter' },
      },
      {
        id: '4',
        type: 'snowball',
        position: { x: -350, y: 300 },
        data: { label: 'Milky Way' },
      },
      {
        id: '5',
        type: 'snowball',
        position: { x: -50, y: 300 },
        data: { label: 'Andromeda' },
      },
      {
        id: '6',
        type: 'snowball',
        position: { x: 150, y: 300 },
        data: { label: 'WIMPs' },
      },
      {
        id: '7',
        type: 'snowball',
        position: { x: 350, y: 300 },
        data: { label: 'Gravitational Lensing' },
      },
    ]

    const initialEdges: Edge[] = [
      { id: 'e1-2', source: '1', target: '2', type: 'footprint' },
      { id: 'e1-3', source: '1', target: '3', type: 'footprint' },
      { id: 'e2-4', source: '2', target: '4', type: 'footprint' },
      { id: 'e2-5', source: '2', target: '5', type: 'footprint' },
      { id: 'e3-6', source: '3', target: '6', type: 'footprint' },
      { id: 'e3-7', source: '3', target: '7', type: 'footprint' },
    ]

    type CanvasStore = {
      nodes: Node[]
      edges: Edge[]
      onNodesChange: OnNodesChange
      onEdgesChange: OnEdgesChange
    }

    export const useCanvasStore = create<CanvasStore>((set, get) => ({
      nodes: initialNodes,
      edges: initialEdges,
      onNodesChange: (changes) => {
        set({ nodes: applyNodeChanges(changes, get().nodes) })
      },
      onEdgesChange: (changes) => {
        set({ edges: applyEdgeChanges(changes, get().edges) })
      },
    }))
    ```

    Include meaningful seed data (7 nodes in a tree structure) so the canvas is NOT empty when loaded. This is critical for visual impact during demos.

    **SnowballNode** (`client/src/components/canvas/nodes/SnowballNode.tsx`):
    Create a memoized custom node styled as a snowball:

    - Use `React.memo` wrapper (CRITICAL per research - prevents re-render during pan/zoom)
    - Set `displayName` for React DevTools
    - Rounded shape: `rounded-2xl` (not fully round - needs to accommodate text)
    - White/frost background: `bg-white/90` with subtle blue inner shadow via `shadow-inner shadow-frost-blue/30` or a custom box-shadow
    - Text: `text-slate-700 font-body text-sm` for readability (Nunito font)
    - Padding: `px-5 py-3` for comfortable text spacing
    - Border: `border border-slate-200/50` subtle frost border
    - Add a subtle hover effect: slight scale increase and brighter shadow via Tailwind `hover:scale-105 hover:shadow-lg hover:shadow-frost-blue/20 transition-all duration-200`
    - Handles: one `<Handle type="target" position={Position.Top} />` and one `<Handle type="source" position={Position.Bottom} />`
    - Style handles to be nearly invisible: small (w-2 h-2), bg-slate-300, border-none, opacity-50
    - Accept `NodeProps` type from @xyflow/react and render `data.label`

    **FootprintEdge** (`client/src/components/canvas/edges/FootprintEdge.tsx`):
    Create a custom edge styled as dashed footprint trails:

    - Use `BaseEdge` and `getBezierPath` from @xyflow/react
    - Style: stroke `#94a3b8` (slate-400), strokeWidth 2, strokeDasharray `'8,6'` (dashed footprint pattern), strokeLinecap `'round'`
    - Keep it simple - the dashed pattern suggests footprints in snow
    - Export as named function (not memo needed for edges)

    IMPORTANT: Define `nodeTypes` and `edgeTypes` objects OUTSIDE any component to prevent re-render loops:

    ```typescript
    // Export these from their respective files or from a shared types file
    // They MUST be defined outside React components
    ```

    Create a barrel export or define nodeTypes/edgeTypes in the InfiniteCanvas file outside the component.
  </action>
  <verify>
    `cd client && npx tsc --noEmit` passes with zero errors.
    All three files export their named exports correctly.
    SnowballNode uses React.memo (grep for "memo" in file).
    FootprintEdge uses strokeDasharray (grep for "Dasharray" in file).
  </verify>
  <done>
    Zustand store created with seed data (7 nodes in tree). SnowballNode is memoized with snowball styling (rounded, white, blue shadow, frost border). FootprintEdge renders dashed lines. nodeTypes and edgeTypes defined outside components.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create InfiniteCanvas component and compose full app with all layers</name>
  <files>
    client/src/components/canvas/InfiniteCanvas.tsx
    client/src/App.tsx
  </files>
  <action>
    **InfiniteCanvas** (`client/src/components/canvas/InfiniteCanvas.tsx`):
    Create the React Flow canvas component following research patterns:

    ```tsx
    import { ReactFlow, Background, Controls, type ReactFlowProps } from '@xyflow/react'
    import '@xyflow/react/dist/style.css'
    import { useCanvasStore } from '../../state/canvasStore'
    import { SnowballNode } from './nodes/SnowballNode'
    import { FootprintEdge } from './edges/FootprintEdge'

    // MUST be defined outside component to prevent re-render loops
    const nodeTypes = { snowball: SnowballNode }
    const edgeTypes = { footprint: FootprintEdge }

    export function InfiniteCanvas() {
      const nodes = useCanvasStore((s) => s.nodes)
      const edges = useCanvasStore((s) => s.edges)
      const onNodesChange = useCanvasStore((s) => s.onNodesChange)
      const onEdgesChange = useCanvasStore((s) => s.onEdgesChange)

      return (
        <div
          className="absolute inset-0"
          style={{ zIndex: 'var(--z-canvas)' }}
        >
          <ReactFlow
            nodes={nodes}
            edges={edges}
            nodeTypes={nodeTypes}
            edgeTypes={edgeTypes}
            onNodesChange={onNodesChange}
            onEdgesChange={onEdgesChange}
            fitView
            minZoom={0.1}
            maxZoom={4}
            proOptions={{ hideAttribution: false }}
          >
            <Background
              color="#334155"
              gap={40}
              size={1}
              style={{ opacity: 0.3 }}
            />
            <Controls
              className="!bg-background-light/80 !border-slate-600 !shadow-lg"
              showInteractive={false}
            />
          </ReactFlow>
        </div>
      )
    }
    ```

    Key implementation details:
    - Import `@xyflow/react/dist/style.css` FIRST (before any custom styles) - this is CRITICAL per research
    - Use `absolute inset-0` positioning with `z-index: var(--z-canvas)` (value: 10) to layer above background
    - Set `fitView` so nodes are visible on load without manual panning
    - Set generous zoom range: `minZoom={0.1}` and `maxZoom={4}` for exploration feel
    - Use React Flow's `<Background>` with subtle slate dots (opacity 0.3) for spatial awareness
    - Include `<Controls>` with custom dark styling to match the moody palette
    - Style Controls with Tailwind: dark translucent background, slate border. Use the `!` important prefix to override React Flow's default Control styles.
    - Do NOT use `proOptions={{ hideAttribution: true }}` if it violates React Flow's free tier - keep attribution visible

    **App.tsx** (`client/src/App.tsx`):
    Compose all layers into the final application:

    ```tsx
    import { ParallaxBackground } from './components/background/ParallaxBackground'
    import { InfiniteCanvas } from './components/canvas/InfiniteCanvas'

    function App() {
      return (
        <div className="relative w-screen h-screen overflow-hidden bg-background-dark">
          {/* Layer 0: Atmospheric background */}
          <ParallaxBackground />

          {/* Layer 10: Interactive canvas */}
          <InfiniteCanvas />

          {/* Layer 40: HUD overlay (Phase 1 - minimal branding) */}
          <div
            className="fixed top-6 left-6 pointer-events-none"
            style={{ zIndex: 'var(--z-hud)' }}
          >
            <h1 className="text-2xl font-heading font-bold text-accent-warm/80 drop-shadow-lg">
              FRACTAL
            </h1>
            <p className="text-xs font-body text-frost/40 mt-0.5">
              explore the snowfield of knowledge
            </p>
          </div>
        </div>
      )
    }

    export default App
    ```

    The App composition must:
    - Use `relative` container with `w-screen h-screen overflow-hidden` (viewport fills screen)
    - Layer components using z-index CSS variables (background: 0, canvas: 10, hud: 40)
    - Include a minimal HUD branding element (FRACTAL title in top-left corner, semi-transparent, pointer-events-none)
    - Background: `bg-background-dark` as fallback color before SVG layers load
    - NOT include snow particles yet (Phase 2+ or later in Phase 1 if time allows)
    - React Flow's canvas must receive pointer events while background does not

    NOTE: This task requires the ParallaxBackground from Plan 02. If Plan 02 has not completed yet, create a temporary placeholder ParallaxBackground that renders a simple gradient div, then the real one will be swapped in when Plan 02 completes. The import path should be correct either way: `./components/background/ParallaxBackground`.

    If importing ParallaxBackground causes a build error because Plan 02 hasn't run yet, create a minimal placeholder at `client/src/components/background/ParallaxBackground.tsx`:
    ```tsx
    export function ParallaxBackground() {
      return (
        <div
          className="fixed inset-0 pointer-events-none"
          style={{
            zIndex: 'var(--z-background)',
            background: 'linear-gradient(180deg, #0f172a 0%, #1e293b 60%, #334155 100%)',
          }}
        />
      )
    }
    ```
    This will be overwritten by Plan 02's actual implementation.
  </action>
  <verify>
    `cd client && npm run dev` starts without errors.
    `cd client && npx tsc --noEmit` passes with zero TypeScript errors.
    Open browser to dev URL:
    1. Background gradient or SVG layers visible behind canvas
    2. Seven snowball nodes visible (white rounded shapes with labels: "The Universe", "Galaxies", etc.)
    3. Dashed footprint edges connect parent nodes to children
    4. Pan works: click and drag moves the canvas
    5. Zoom works: scroll wheel zooms in/out smoothly
    6. Nodes are draggable: click and drag a node moves it
    7. "FRACTAL" branding visible in top-left corner
    8. Controls widget visible in bottom-left (zoom in/out/fit buttons)
    9. React Flow's Background dot grid is subtly visible
    10. No console errors or React warnings
  </verify>
  <done>
    Interactive infinite canvas renders with 7 custom snowball nodes in a tree layout, connected by dashed footprint edges. User can pan, zoom, and drag nodes smoothly. Canvas layers correctly above the parallax background. FRACTAL branding overlays in the top-left. The full composition creates a cohesive moody winter exploration interface.
  </done>
</task>

</tasks>

<verification>
1. `cd client && npm run dev` runs with zero errors
2. `cd client && npx tsc --noEmit` compiles cleanly
3. Canvas renders 7 snowball nodes with readable labels
4. 6 footprint edges connect nodes in tree structure
5. Pan and zoom work smoothly (no jank, no re-render loops)
6. Nodes are draggable
7. Background layers visible behind canvas (gradient at minimum, SVG layers if Plan 02 complete)
8. Z-index layering correct: background behind canvas behind HUD
9. Controls widget styled dark to match palette
10. No React warnings about nodeTypes/edgeTypes in console
11. FRACTAL branding renders in Fredoka font with amber color in top-left
</verification>

<success_criteria>
- User can pan and zoom smoothly across the infinite canvas (CANV-01)
- Snowball nodes are rounded white with blue shadow and readable Nunito text (CANV-02)
- Footprint edges are dashed slate lines connecting nodes (CANV-03)
- All layers compose correctly: background (z-0) -> canvas (z-10) -> HUD (z-40)
- Seed data provides immediate visual impact (no empty canvas)
- No re-render loops or performance issues during pan/zoom/drag
- TypeScript compiles with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-atmosphere/01-03-SUMMARY.md`
</output>
