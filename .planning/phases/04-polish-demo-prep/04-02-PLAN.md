---
phase: 04-polish-demo-prep
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - client/src/state/canvasStore.ts
  - client/src/components/ui/SoundToggle.tsx
  - client/src/App.tsx
  - client/public/audio/wind-calm.mp3
  - client/public/audio/wind-blizzard.mp3
autonomous: true

must_haves:
  truths:
    - "Soft ambient wind plays during peace mode"
    - "Wind intensifies with howling during blizzard mode"
    - "User can mute/unmute sound with a visible toggle"
    - "Sound transitions smoothly between peace and blizzard modes"
    - "Demo runs without crashes or performance issues for 3+ minutes"
  artifacts:
    - path: "client/src/components/ui/SoundToggle.tsx"
      provides: "Mute/unmute toggle button component"
      min_lines: 15
    - path: "client/src/state/canvasStore.ts"
      provides: "Sound muted state and toggle action"
      contains: "soundMuted"
    - path: "client/src/App.tsx"
      provides: "Audio elements and sound toggle mounted in app"
      contains: "SoundToggle"
    - path: "client/public/audio/wind-calm.mp3"
      provides: "Calm wind ambient loop"
    - path: "client/public/audio/wind-blizzard.mp3"
      provides: "Blizzard wind ambient loop"
  key_links:
    - from: "client/src/state/canvasStore.ts"
      to: "client/src/App.tsx"
      via: "gameMode and soundMuted state drive audio playback"
      pattern: "soundMuted|gameMode"
    - from: "client/src/App.tsx"
      to: "client/public/audio/"
      via: "HTML audio elements reference public audio files"
      pattern: "audio.*wind"
---

<objective>
Add ambient sound design with peace/blizzard modes and a mute toggle, plus ensure demo reliability for judging.

Purpose: Sound design creates immersion that separates this from typical hackathon projects. Judges often evaluate with sound on. The mute toggle ensures graceful handling if sound is unwanted. Demo reliability ensures the 3-minute narrative runs flawlessly.
Output: Working ambient audio system with mode transitions and mute toggle
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@client/src/state/canvasStore.ts
@client/src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Generate ambient audio files and add sound state to store</name>
  <files>
    client/public/audio/wind-calm.mp3
    client/public/audio/wind-blizzard.mp3
    client/src/state/canvasStore.ts
  </files>
  <action>
**Audio files:**
Create directory `client/public/audio/`. We need two short ambient audio loops. Since we cannot generate audio programmatically in this context, create placeholder approach:

Use the Web Audio API approach instead of MP3 files. Delete the audio file plan. Instead, we will synthesize wind sounds using the Web Audio API directly in the browser. This avoids needing to source/download MP3 files during a hackathon.

Create a new file `client/src/audio/windSynth.ts` that exports a `WindSynthesizer` class:

```typescript
// Wind synthesizer using Web Audio API - no external audio files needed
export class WindSynthesizer {
  private ctx: AudioContext | null = null
  private gainNode: GainNode | null = null
  private noiseNode: AudioBufferSourceNode | null = null
  private filterNode: BiquadFilterNode | null = null
  private isPlaying = false
  private mode: 'calm' | 'blizzard' = 'calm'

  init() {
    if (this.ctx) return
    this.ctx = new AudioContext()
    this.gainNode = this.ctx.createGain()
    this.gainNode.gain.value = 0
    this.filterNode = this.ctx.createBiquadFilter()
    this.filterNode.type = 'lowpass'
    this.filterNode.frequency.value = 400
    this.filterNode.Q.value = 1
    this.gainNode.connect(this.ctx.destination)
    this.filterNode.connect(this.gainNode)
  }

  private createNoiseBuffer(): AudioBuffer {
    const ctx = this.ctx!
    const bufferSize = ctx.sampleRate * 4 // 4 second buffer
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate)
    const data = buffer.getChannelData(0)
    for (let i = 0; i < bufferSize; i++) {
      data[i] = (Math.random() * 2 - 1) * 0.5
    }
    return buffer
  }

  play() {
    if (!this.ctx || this.isPlaying) return
    if (this.ctx.state === 'suspended') this.ctx.resume()

    const buffer = this.createNoiseBuffer()
    this.noiseNode = this.ctx.createBufferSource()
    this.noiseNode.buffer = buffer
    this.noiseNode.loop = true
    this.noiseNode.connect(this.filterNode!)
    this.noiseNode.start()
    this.isPlaying = true
    this.applyMode(this.mode)
  }

  stop() {
    if (this.noiseNode) {
      this.noiseNode.stop()
      this.noiseNode.disconnect()
      this.noiseNode = null
    }
    this.isPlaying = false
  }

  setMode(mode: 'calm' | 'blizzard') {
    this.mode = mode
    if (this.isPlaying) this.applyMode(mode)
  }

  private applyMode(mode: 'calm' | 'blizzard') {
    if (!this.ctx || !this.gainNode || !this.filterNode) return
    const now = this.ctx.currentTime
    if (mode === 'calm') {
      this.gainNode.gain.linearRampToValueAtTime(0.08, now + 1.5)
      this.filterNode.frequency.linearRampToValueAtTime(400, now + 1.5)
    } else {
      this.gainNode.gain.linearRampToValueAtTime(0.25, now + 1.5)
      this.filterNode.frequency.linearRampToValueAtTime(1200, now + 1.5)
    }
  }

  setMuted(muted: boolean) {
    if (muted) {
      this.stop()
    } else if (!this.isPlaying) {
      this.play()
    }
  }
}
```

Key design decisions:
- White noise through a lowpass filter = wind sound. Calm mode: low gain (0.08), low cutoff (400Hz) = soft breeze. Blizzard mode: higher gain (0.25), higher cutoff (1200Hz) = howling wind.
- 1.5s ramp time matches the atmosphere transition duration from Phase 3.
- No external files needed — pure Web Audio API synthesis.
- `init()` must be called from a user gesture (click) to satisfy browser autoplay policy.

**canvasStore.ts:**
Add to the CanvasStore type:
- `soundMuted: boolean` (state)
- `toggleSound: () => void` (action)

Add to the store implementation:
- `soundMuted: true` (start muted — user opts in to sound, avoids autoplay issues)
- `toggleSound: () => { set((state) => ({ soundMuted: !state.soundMuted })) }`

Do NOT modify any existing state, actions, or logic. Only add the two new fields.
  </action>
  <verify>Run `cd /Users/sahilpatel/Developer/tidalhack-2026/client && npx tsc --noEmit` to confirm no type errors. Verify canvasStore.ts has soundMuted and toggleSound. Verify windSynth.ts exists with WindSynthesizer class.</verify>
  <done>WindSynthesizer class created with Web Audio API wind synthesis (calm/blizzard modes, 1.5s transitions). canvasStore has soundMuted state (default true) and toggleSound action.</done>
</task>

<task type="auto">
  <name>Task 2: Create SoundToggle component and wire audio into App</name>
  <files>
    client/src/components/ui/SoundToggle.tsx
    client/src/App.tsx
  </files>
  <action>
**SoundToggle.tsx:**
Create a new component that shows a mute/unmute button. Use frosted-glass styling (matching the DemoToggle pattern from Plan 01, but if Plan 01 hasn't run yet, use inline: `bg-slate-900/70 backdrop-blur-[12px] border border-slate-400/30 rounded-lg`).

```tsx
import { useCanvasStore } from '../../state/canvasStore'

export function SoundToggle() {
  const soundMuted = useCanvasStore((state) => state.soundMuted)
  const toggleSound = useCanvasStore((state) => state.toggleSound)

  return (
    <button
      onClick={toggleSound}
      className="frosted-glass rounded-lg px-3 py-1.5 text-frost/60 hover:text-frost transition-colors text-sm font-body flex items-center gap-1.5"
      aria-label={soundMuted ? 'Unmute sound' : 'Mute sound'}
      title={soundMuted ? 'Unmute sound' : 'Mute sound'}
    >
      {soundMuted ? (
        // Muted icon - speaker with X (inline SVG, no external dep)
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" />
          <line x1="23" y1="9" x2="17" y2="15" />
          <line x1="17" y1="9" x2="23" y2="15" />
        </svg>
      ) : (
        // Unmuted icon - speaker with waves
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" />
          <path d="M15.54 8.46a5 5 0 0 1 0 7.07" />
          <path d="M19.07 4.93a10 10 0 0 1 0 14.14" />
        </svg>
      )}
      <span className="text-xs">{soundMuted ? 'OFF' : 'ON'}</span>
    </button>
  )
}
```

**App.tsx:**
1. Import `SoundToggle` from `./components/ui/SoundToggle`
2. Import `WindSynthesizer` from `./audio/windSynth`
3. Import `useEffect, useRef` from `react`
4. Import `useCanvasStore` (already imported)

Inside the App component, add:
```tsx
const soundMuted = useCanvasStore((state) => state.soundMuted)
const windRef = useRef<WindSynthesizer | null>(null)

// Initialize wind synth on first user interaction
useEffect(() => {
  const wind = new WindSynthesizer()
  windRef.current = wind

  const initAudio = () => {
    wind.init()
    if (!soundMuted) wind.play()
    // Remove listener after first interaction
    document.removeEventListener('click', initAudio)
  }
  document.addEventListener('click', initAudio)

  return () => {
    document.removeEventListener('click', initAudio)
    wind.stop()
  }
}, []) // eslint-disable-line react-hooks/exhaustive-deps

// Sync mute state
useEffect(() => {
  windRef.current?.setMuted(soundMuted)
}, [soundMuted])

// Sync game mode to wind intensity
useEffect(() => {
  windRef.current?.setMode(gameMode)
}, [gameMode])
```

Mount the SoundToggle next to the DemoToggle in the top-right HUD area. Update the existing `fixed top-8 right-8` div to include both:

```tsx
{/* Demo Mode Toggle + Sound Toggle */}
<div
  className="fixed top-8 right-8 pointer-events-auto flex items-center gap-2"
  style={{ zIndex: 'var(--z-hud)' }}
>
  <SoundToggle />
  <DemoToggle />
</div>
```

CRITICAL: The `soundMuted` default is `true` (muted). Sound only plays AFTER user clicks anywhere AND toggles sound on. This respects browser autoplay policies and avoids surprising judges with unexpected audio.

Do NOT change the existing DemoToggle component or any other HUD elements. Only add SoundToggle and audio wiring.
  </action>
  <verify>Run `cd /Users/sahilpatel/Developer/tidalhack-2026/client && npx tsc --noEmit` to confirm no type errors. Run `cd /Users/sahilpatel/Developer/tidalhack-2026/client && npm run build` to confirm build succeeds. Verify SoundToggle.tsx exists, App.tsx imports and mounts it, and windSynth.ts is wired into App via useEffect.</verify>
  <done>SoundToggle renders in top-right HUD with mute/unmute icons. Wind synthesizer produces soft breeze in peace mode and howling wind in blizzard mode. Sound starts muted and only plays after user interaction + toggle. 1.5s smooth transitions between modes. Build passes with zero errors.</done>
</task>

</tasks>

<verification>
1. `cd /Users/sahilpatel/Developer/tidalhack-2026/client && npm run build` completes without errors
2. SoundToggle.tsx exists with speaker icons and frosted glass styling
3. windSynth.ts exists with WindSynthesizer class (Web Audio API, no external files)
4. App.tsx mounts SoundToggle and wires WindSynthesizer to gameMode/soundMuted state
5. canvasStore.ts has soundMuted (default true) and toggleSound action
6. Sound starts muted (respects autoplay policy)
7. Mode transitions use 1.5s ramp matching atmosphere transitions
</verification>

<success_criteria>
- Soft wind ambient plays in peace mode when unmuted
- Wind howls louder with higher frequencies in blizzard mode
- Smooth 1.5s audio transitions between modes
- Mute/unmute toggle visible in top-right HUD next to demo toggle
- Sound defaults to muted (no autoplay surprises)
- No external audio files needed (Web Audio API synthesis)
- Build passes with zero errors
- App runs for 3+ minutes without crashes or performance degradation
</success_criteria>

<output>
After completion, create `.planning/phases/04-polish-demo-prep/04-02-SUMMARY.md`
</output>
