---
phase: 02-ai-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/package.json
  - server/tsconfig.json
  - server/.env.example
  - server/src/server.ts
  - server/src/config/db.ts
  - server/src/config/env.ts
  - server/src/models/CachedResponse.ts
  - server/src/services/featherless.ts
  - server/src/services/gemini.ts
  - server/src/services/cache.ts
  - server/src/controllers/scoutController.ts
  - server/src/controllers/hoverController.ts
  - server/src/middleware/errorHandler.ts
  - server/src/routes/api.ts
  - server/src/types/index.ts
autonomous: true
user_setup:
  - service: featherless
    why: "AI sub-topic generation"
    env_vars:
      - name: FEATHERLESS_API_KEY
        source: "Featherless dashboard (user already has key)"
  - service: gemini
    why: "AI summaries and quiz generation"
    env_vars:
      - name: GEMINI_API_KEY
        source: "Google AI Studio (user already has key)"
  - service: mongodb
    why: "Caching AI responses"
    env_vars:
      - name: MONGODB_URI
        source: "MongoDB Atlas or local MongoDB instance"

must_haves:
  truths:
    - "POST /api/scout returns 4 sub-topics with embedded quiz data for a given topic"
    - "POST /api/hover returns a fun fact for a given topic"
    - "Repeated requests for the same topic return cached responses from MongoDB"
    - "Server validates environment variables at startup and fails fast if missing"
  artifacts:
    - path: "server/src/server.ts"
      provides: "Express entry point with MongoDB connection"
      min_lines: 20
    - path: "server/src/services/featherless.ts"
      provides: "Featherless API integration via OpenAI SDK"
      exports: ["generateSubTopics"]
    - path: "server/src/services/gemini.ts"
      provides: "Gemini API integration for fun facts and quizzes"
      exports: ["generateFunFact", "generateQuiz"]
    - path: "server/src/models/CachedResponse.ts"
      provides: "MongoDB schema with TTL index"
      contains: "expires"
    - path: "server/src/routes/api.ts"
      provides: "API route definitions"
      contains: "/scout"
  key_links:
    - from: "server/src/routes/api.ts"
      to: "server/src/controllers/scoutController.ts"
      via: "route handler"
      pattern: "scoutController"
    - from: "server/src/controllers/scoutController.ts"
      to: "server/src/services/featherless.ts"
      via: "service call"
      pattern: "generateSubTopics"
    - from: "server/src/controllers/scoutController.ts"
      to: "server/src/services/gemini.ts"
      via: "quiz generation"
      pattern: "generateQuiz"
    - from: "server/src/controllers/scoutController.ts"
      to: "server/src/models/CachedResponse.ts"
      via: "cache check and store"
      pattern: "CachedResponse"
---

<objective>
Build the Express backend with MongoDB caching, Featherless sub-topic generation, and Gemini summary/quiz generation.

Purpose: Provides the AI-powered API layer that the frontend will call to dynamically generate sub-topics, fun facts, and quizzes — the core intelligence behind FRACTAL's knowledge exploration.

Output: A running Express server at localhost:3000 with two endpoints: POST /api/scout (returns 4 sub-topics + embedded quiz data) and POST /api/hover (returns a fun fact). All responses cached in MongoDB with 24hr TTL.
</objective>

<execution_context>
@/Users/sahilpatel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sahilpatel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-ai-integration/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold Express server with MongoDB, env validation, and cache model</name>
  <files>
    server/package.json
    server/tsconfig.json
    server/.env.example
    server/src/server.ts
    server/src/config/db.ts
    server/src/config/env.ts
    server/src/models/CachedResponse.ts
    server/src/middleware/errorHandler.ts
    server/src/types/index.ts
  </files>
  <action>
    Create the server/ directory at project root (sibling to client/).

    1. Initialize with package.json:
       - Dependencies: express, mongoose, dotenv, cors, openai, @google/genai
       - Dev deps: typescript, @types/express, @types/node, @types/cors, tsx (for dev running)
       - Scripts: "dev": "tsx watch src/server.ts", "build": "tsc", "start": "node dist/server.js"
       - Use Express 4.x (stable) with express-async-errors for async handling

    2. Create tsconfig.json: target ES2022, module NodeNext, moduleResolution NodeNext, outDir dist, rootDir src, strict true, esModuleInterop true

    3. Create .env.example with: FEATHERLESS_API_KEY, GEMINI_API_KEY, MONGODB_URI, PORT=3000, CLIENT_URL=http://localhost:5173

    4. Create src/config/env.ts:
       - Load dotenv
       - Validate required vars: FEATHERLESS_API_KEY, GEMINI_API_KEY, MONGODB_URI
       - Export typed config object
       - Throw on missing vars with clear error message

    5. Create src/config/db.ts:
       - Export connectDB() that awaits mongoose.connect() with MONGODB_URI
       - Log success, exit process on failure (fail fast)

    6. Create src/models/CachedResponse.ts:
       - Mongoose schema with: key (String, required, unique, indexed), type (String: 'scout'|'hover'), data (Mixed, required), createdAt (Date, default now, expires: 86400 for 24hr TTL)
       - Export CachedResponse model

    7. Create src/middleware/errorHandler.ts:
       - Express error handler (4 args)
       - Log error, return JSON with message
       - Include stack in development mode only

    8. Create src/types/index.ts:
       - SubTopic type: { label: string, quiz: QuizData | null }
       - QuizData type: { question: string, options: string[], correctIndex: number }
       - ScoutResponse type: { subTopics: SubTopic[] }
       - HoverResponse type: { funFact: string }

    9. Create src/server.ts:
       - Import express-async-errors at top (must be first)
       - Import env config (triggers validation)
       - Create Express app with json parsing and cors (origin from CLIENT_URL)
       - Mount API routes at /api
       - Add error handler middleware last
       - Connect to MongoDB, then listen on PORT
       - Log startup success
  </action>
  <verify>
    cd server && npm install && npx tsc --noEmit
    Verify: TypeScript compiles without errors, all imports resolve
  </verify>
  <done>Server scaffold compiles cleanly. MongoDB model has TTL index. Env validation throws on missing vars. Error handler returns structured JSON.</done>
</task>

<task type="auto">
  <name>Task 2: Implement AI services, controllers, and API routes</name>
  <files>
    server/src/services/featherless.ts
    server/src/services/gemini.ts
    server/src/services/cache.ts
    server/src/controllers/scoutController.ts
    server/src/controllers/hoverController.ts
    server/src/routes/api.ts
  </files>
  <action>
    1. Create src/services/featherless.ts:
       - Import OpenAI from 'openai'
       - Create client with baseURL 'https://api.featherless.ai/v1' and FEATHERLESS_API_KEY
       - Export generateSubTopics(parentTopic: string): Promise<string[]>
       - System prompt: "You are a knowledge exploration assistant. Given a topic, generate exactly 4 interesting and educational sub-topics. Return ONLY a JSON array of 4 strings, nothing else. Each sub-topic should be concise (2-5 words)."
       - User prompt: "Parent topic: {parentTopic}"
       - Use model: 'Qwen/Qwen3-32B' (strong general-purpose model on Featherless)
       - Parse response as JSON array, validate it has exactly 4 items, fallback to empty array
       - Wrap in try-catch: on 429 throw "Rate limit exceeded", on other errors throw "Failed to generate sub-topics"

    2. Create src/services/gemini.ts:
       - Import GoogleGenAI from '@google/genai'
       - Create client with GEMINI_API_KEY
       - Export generateFunFact(topic: string): Promise<string>
         - Prompt: "Share one fascinating, concise fun fact about '{topic}' in 1-2 sentences. Make it surprising and educational. If possible, add a winter or nature metaphor."
         - Use model: 'gemini-2.5-flash'
         - Return text response
       - Export generateQuiz(topic: string): Promise<QuizData | null>
         - Prompt: "Create a multiple-choice quiz question about '{topic}'. Return ONLY valid JSON with this exact structure: {\"question\": \"...\", \"options\": [\"A\", \"B\", \"C\", \"D\"], \"correctIndex\": 0}. The question should be educational and engaging. Include a winter metaphor if natural."
         - Parse JSON from response (use regex to extract JSON object from potential markdown wrapping)
         - Validate structure (has question, 4 options, valid correctIndex 0-3)
         - Return null on parse failure (graceful degradation)
       - Wrap both in try-catch with user-friendly error messages

    3. Create src/services/cache.ts:
       - Import CachedResponse model
       - Export get(key: string): Promise<any | null> — findOne by key, return data or null
       - Export set(key: string, type: string, data: any): Promise<void> — upsert (findOneAndUpdate with upsert:true) to handle race conditions

    4. Create src/controllers/scoutController.ts:
       - Export expandNode(req, res): async handler
       - Extract topic from req.body, validate it exists (400 if missing)
       - Cache key: `scout:${topic.toLowerCase().trim()}`
       - Check cache first via cacheService.get()
       - On cache hit: return { data: cached, source: 'cache' }
       - On cache miss:
         a. Call featherless.generateSubTopics(topic) for 4 sub-topics
         b. Call gemini.generateQuiz() for each sub-topic in parallel (Promise.all)
         c. Build SubTopic[] array with label + quiz
         d. Cache result via cacheService.set()
         e. Return { data: { subTopics }, source: 'api' }

    5. Create src/controllers/hoverController.ts:
       - Export getFunFact(req, res): async handler
       - Extract topic from req.body, validate (400 if missing)
       - Cache key: `hover:${topic.toLowerCase().trim()}`
       - Check cache, return on hit
       - On miss: call gemini.generateFunFact(topic), cache, return { data: { funFact }, source: 'api' }

    6. Create src/routes/api.ts:
       - Import Router from express
       - POST /scout -> scoutController.expandNode
       - POST /hover -> hoverController.getFunFact
       - GET /health -> return { status: 'ok', timestamp }
       - Export router

    7. Update src/server.ts to import and mount the routes:
       - import apiRoutes from './routes/api'
       - app.use('/api', apiRoutes)
  </action>
  <verify>
    cd server && npx tsc --noEmit
    Verify: Full compilation passes. All services, controllers, routes, and types resolve correctly.
    Manual: Start server with valid .env, hit GET /api/health, confirm { status: 'ok' }
  </verify>
  <done>Two API endpoints fully implemented: POST /api/scout returns 4 sub-topics with embedded quiz JSON, POST /api/hover returns a fun fact. Both check MongoDB cache first. TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
1. `cd server && npx tsc --noEmit` — TypeScript compiles without errors
2. `cd server && npm run dev` with valid .env — server starts, connects to MongoDB
3. `curl http://localhost:3000/api/health` — returns { status: 'ok' }
4. `curl -X POST http://localhost:3000/api/scout -H 'Content-Type: application/json' -d '{"topic":"The Universe"}'` — returns 4 sub-topics with quiz data
5. Repeat same curl — returns source: 'cache'
6. `curl -X POST http://localhost:3000/api/hover -H 'Content-Type: application/json' -d '{"topic":"Galaxies"}'` — returns fun fact
</verification>

<success_criteria>
- Express server starts and connects to MongoDB
- POST /api/scout returns exactly 4 sub-topics, each with embedded quiz data (or null)
- POST /api/hover returns a fun fact string
- Second request for same topic returns from cache (source: 'cache')
- Missing topic returns 400 error
- Server validates env vars at startup
- TypeScript compiles cleanly with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-ai-integration/02-01-SUMMARY.md`
</output>
